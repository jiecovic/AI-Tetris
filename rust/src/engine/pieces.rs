// src/pieces.rs
#[derive(Clone, Copy, Debug)]
pub enum Kind {
    I,
    O,
    T,
    S,
    Z,
    J,
    L,
}

impl Kind {
    pub fn all() -> &'static [Kind] {
        use Kind::*;
        &[I, O, T, S, Z, J, L]
    }

    pub fn idx(self) -> u8 {
        use Kind::*;
        match self {
            I => 1,
            O => 2,
            T => 3,
            S => 4,
            Z => 5,
            J => 6,
            L => 7,
        }
    }

    pub fn glyph(self) -> char {
        use Kind::*;
        match self {
            I => 'I',
            O => 'O',
            T => 'T',
            S => 'S',
            Z => 'Z',
            J => 'J',
            L => 'L',
        }
    }
}

/// Rotations are represented as (dx, dy) offsets.
/// `rotations(kind)[rot]` returns a slice of 4 blocks.
pub fn rotations(kind: Kind) -> [&'static [(i32, i32)]; 4] {
    use Kind::*;
    match kind {
        O => [
            &[(0, 0), (1, 0), (0, 1), (1, 1)],
            &[(0, 0), (1, 0), (0, 1), (1, 1)],
            &[(0, 0), (1, 0), (0, 1), (1, 1)],
            &[(0, 0), (1, 0), (0, 1), (1, 1)],
        ],
        I => [
            &[(0, 0), (1, 0), (2, 0), (3, 0)],
            &[(1, 0), (1, 1), (1, 2), (1, 3)],
            &[(0, 1), (1, 1), (2, 1), (3, 1)],
            &[(2, 0), (2, 1), (2, 2), (2, 3)],
        ],
        T => [
            &[(1, 0), (0, 1), (1, 1), (2, 1)],
            &[(1, 0), (1, 1), (2, 1), (1, 2)],
            &[(0, 1), (1, 1), (2, 1), (1, 2)],
            &[(1, 0), (0, 1), (1, 1), (1, 2)],
        ],
        S => [
            &[(1, 0), (2, 0), (0, 1), (1, 1)],
            &[(1, 0), (1, 1), (2, 1), (2, 2)],
            &[(1, 1), (2, 1), (0, 2), (1, 2)],
            &[(0, 0), (0, 1), (1, 1), (1, 2)],
        ],
        Z => [
            &[(0, 0), (1, 0), (1, 1), (2, 1)],
            &[(2, 0), (1, 1), (2, 1), (1, 2)],
            &[(0, 1), (1, 1), (1, 2), (2, 2)],
            &[(1, 0), (0, 1), (1, 1), (0, 2)],
        ],
        J => [
            &[(0, 0), (0, 1), (1, 1), (2, 1)],
            &[(1, 0), (2, 0), (1, 1), (1, 2)],
            &[(0, 1), (1, 1), (2, 1), (2, 2)],
            &[(1, 0), (1, 1), (0, 2), (1, 2)],
        ],
        L => [
            &[(2, 0), (0, 1), (1, 1), (2, 1)],
            &[(1, 0), (1, 1), (1, 2), (2, 2)],
            &[(0, 1), (1, 1), (2, 1), (0, 2)],
            &[(0, 0), (1, 0), (1, 1), (1, 2)],
        ],
    }
}
